# 你理解的多线程

## 第一种:pthread
a特点:
1)一套通用的多线程API 
2)适用于Unix\Linux\Windows等系统 
3)跨平台\可移植
4)使用难度大

b.使用语言:c语言
c.使用频率:几乎不用
d.线程生命周期:由程序员进行管理

## 第二种:NSThread
a特点:
1)使用更加面向对象
2)简单易用，可直接操作线程对象

b.使用语言:OC语言
c.使用频率:偶尔使用
d.线程生命周期:由程序员进行管理


## 第三种:GCD
a.特点:
1)旨在替代NSThread等线程技术
2)充分利用设备的多核(自动)


b.使用语言:C语言
c.使用频率:经常使用
d.线程生命周期:自动管理

## 第四种:NSOperation
a.特点: 
1)基于GCD(底层是GCD) 
2)比GCD多了一些更简单实用的功能 
3)使用更加面向对象

b.使用语言:OC语言 
c.使用频率:经常使用
d.线程生命周期:自动管理


## 多线程的原理
同一时间，CPU只能处理1条线程，只有1条线程在工作(执行) 多线程并发(同时)执行，其实是CPU快速地在多条线程之间调度(切换) 如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象 思考:如果线程非常非常多，会发生什么情况?
CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源 每条线程被调度执行的频次会降低(线程的执行效率降低)


## 多线程的优点

能适当提高程序的执行效率 
能适当提高资源利用率(CPU、内存利用率)

## 多线程的缺点
开启线程需要占用一定的内存空间(默认情况下，主线程占用1M，子线程占用 512KB)，如果开启大量的线程，会占用大量的内存空间，降低程序的性能
线程越多，CPU在调度线程上的开销就越大 程序设计更加复杂:比如线程之间的通信、多线程的数据共享



## 你更倾向于哪一种?
**倾向于GCD:**
GCD技术是一个轻量的，底层实现隐藏的神奇技术，我们能够通过GCD和block 轻松实现多线程编程，有时候，GCD相比其他系统提供的多线程方法更加有 效，当然，有时候GCD不是最佳选择，另一个多线程编程的技术 NSOprationQueue 让我们能够将后台线程以队列方式依序执行，并提供更多操作的入口，这和 GCD 的实现有些类似。
这种类似不是一个巧合，在早期，MacOX 与 iOS 的程序都普遍采用Operation Queue来进行编写后台线程代码，而之后出现的GCD技术大体是依照前者的原 则来实现的，而随着GCD的普及，在iOS 4 与 MacOS X 10.6以后，Operation Queue的底层实现都是用GCD来实现的




## 那这两者直接有什么区别呢?
1. GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc 的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的 数据结构;而Operation作为一个对象，为我们提供了更多的选择;
2. 在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当 然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其 实是有的，但需要许多复杂的代码);
3. NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于 另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者 会直到后者执行完毕后再执行;
4. 我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或 取消，这样子能比GCD更加有效地掌控我们执行的后台任务;
5. 在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同 一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务 队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码;
6. 我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法， 提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能 够在其之上添加更多自定制的功能

总的来说，Operation queue 提供了更多你在编写多线程程序时需要的功能， 并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单 的API入又。从编程原则来说，一般我们需要尽可能的使用高等级、封装完美 的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的 底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择



**倾向于:NSOperation**
NSOperation相对于GCD:

1，NSOperation拥有更多的函数可用，具体查看api。NSOperationQueue 是在 GCD基础上实现的，只不过是GCD更高一层的抽象。
2，在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。 3，NSOperationQueue支持KVO。可以监测operation是否正在执行
(isExecuted)、是否结束(isFinished)，是否取消(isCanceld)
4，GCD只支持FIFO的队列，而NSOperationQueue可以调整队列的执行顺序(通 过调整权重)。NSOperationQueue可以方便的管理并发、NSOperation之间的优 先级


使用NSOperation的情况:各个操作之间有依赖关系、操作需要取消暂停、并发 管理、控制操作之间优先级，限制同时能执行的线程数量.让线程在某时刻停止 /继续等


使用GCD的情况:一般的需求很简单的多线程操作，用GCD都可以了，简单高效

从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API



## GCD执行原理

GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”
很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被 调用胡话，这个线程就会被销毁。注意:开多少条线程是由底层线程池决定的 (线程建议控制再3~5条)，池是系统自动来维护，不需要我们程序员来维护.


而我们程序员需要关心的是什么呢?我们只关心的是向队列中添加任务，队列 调度即可
* 如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条 线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的 任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是 同一条线程
* 如果队列中存放的是异步的任务，(注意异步可以开线程)，当任务出队 后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务 不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次 提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中
* 这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程， 也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通 常只能开5~8条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应 用中，建议开启线程条数:3~5条最为合理




## GCD注意的问题