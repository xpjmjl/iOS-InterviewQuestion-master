### 内存布局相关面试题

![](./img/Snip20190302_85.png) 

* stack:栈区， 方法调用。
* heap: 堆区, 初始化对象等
* .bss: 未初始化的全局变量、静态变量等
* .data: 已初始化的全部变量等
* text: 程序的代码段


![](./img/Snip20190327_32.png)


#### 介绍下内存的几大区域
1.栈区(stack) 由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结 构，对应线程/进程是唯一的。优点是快速高效，缺点时有限制，数据不灵活。[先进后出]

栈空间分静态分配 和动态分配两种
```
静态分配是编译器完成的,比如自动变量(auto)的分配。
动态分配是有alloc函数完成。
栈的动态分配无需释放,是自动的，也没有释放函数
为可移植的程序起见,栈的动态分配操作是不被鼓励的
```

2.堆区(heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回 收 ，比如在ios 中 alloc 都是存放在堆中。  优点是灵活方便，数据适应面广泛，但是效率有一定降低
 
 
```
堆区(heap)由函数库内部数据结构,不一定是唯一。
不同堆的内存无法相互操作
堆空间的分配是动态的
```

虽然程序结束时所有的数据空间都会被释放回系统,但是精确的申请内存,释放内存匹配是良好程序的基本要素。



3. 全局区(静态区) (static) 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静 态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后 有系统释放


```
全局区又可分为未初始化全局区：
.bss段和初始化全局区:data段
举例： int a;未初始化的。 int a =10; 已初始化的
```


4. 文字常量区： 存放常量字符串,程序结束后由系统释放

5. 代码区 存放函数的二进制代码


大致如图:
![](./img/Snip20190605_4.png)


**可能被追问的问题一**

1.栈区 (stack [stæk]): 由编译器自动分配释放  局部变量是保存在栈区的  方法调用的实参也是保存在栈区的
 
2.堆区 (heap [hiːp]): 由程序员分配释放，若程序员不释放，会出现内存泄漏，赋值语句右侧
使用 new 方法创建的对象，被创建对象的所有 成员变量 


3.BSS 段 : 程序结束后由系统释放

4.数据段 : 程序结束后由系统释放
 5.代码段:程序结束后由系统释放  程序编译链接 后的二进制可执行代码
 
 
 
 **可能被追问的问题二**
 比如申请后的系统是如何响应的?
 1. 栈:存储每⼀一个函数在执⾏行行的时候都会向操作系统索要资源，栈区就是函数运⾏行行时的 内存，栈区中的变量量由编译器器负责分配和释放，内存随着函数的运⾏行行分配，随着函数 的结束⽽而释放，由系统⾃自动完成。  注意:只要栈的剩余空间⼤大于所申请空间，系统将为程序提供内存，否则将报异常提 示栈溢出
 
 
 2. 堆: 
1.⾸先应该知道操作系统有一个记录空闲内存地址的链表。

2.当系统收到程序的申请时，会遍历该链表，寻找第⼀一个空间⼤大于所申请空间的堆 结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。 
3 .由于找到的堆结点的⼤小不⼀定正好等于申请的⼤小，系统会⾃动的将多余的那部分重新放⼊入空闲链表中



**可能被追问的问题三**
⽐如:申请⼤小的限制是怎样的?
1.栈:栈是向低地址扩展的数据结构，是⼀一块连续的内存的区域。是栈顶的地址和栈的 最⼤大容量量是系统预先规定好的，栈的⼤大⼩小是2M(也有的说是1M，总之是⼀一个编译时 就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。因 此，能从栈获得的空间较⼩

2.堆:堆是向⾼高地址扩展的数据结构，是不不连续的内存区域。这是由于系统是用链表来 存储的空闲内存地址的，⾃自然是不不连续的，⽽而链表的遍历⽅向是由低地址向高地址。 堆的⼤大⼩小受限于计算机系统中有效的虚拟内存。由此可⻅，堆获得的空间⽐比较灵活，
也⽐比较⼤大


栈:由系统⾃自动分配，速度较快，不不会产⽣生内存碎⽚片  堆:是由alloc分配的内存，速度⽐比较慢，而且容易产生内存碎片，不过用起来最⽅便

